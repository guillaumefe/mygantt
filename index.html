<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Gantt</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        .table-container {
            height: calc(100vh - 100px);
            overflow: auto;
        }
        .gantt-table {
            border-collapse: collapse;
            width: 100%;
        }
        .gantt-table th {
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
            border: 1px solid #dbdbdb;
            height: 27px;
            font-size: 12px;
            font-weight: 600;
        }
        .gantt-table td {
            border: 1px solid #dbdbdb;
            min-width: 40px;
            padding: 0;
        }
        .task-cell {
            width: 500px;
            padding: 0 0.5em !important;
            position: sticky;
            left: 0;
            z-index: 1;
            display: flex;
            align-items: center;
        }
        .group-row .task-cell {
            height: 27px;
            font-size: 14px;
            font-weight: 500;
            background: #f5f5f5;
        }
        .group-row .timeline-cell {
            height: 27px;
        }
        .task-row:not(.group-row) .task-cell {
            font-size: 11px;
            color: #666;
            background: white;
        }
        .task-row:not(.group-row) .timeline-cell {
            height: 18px;
        }
        .task-level-0 { padding-left: 0.5em !important; }
        .task-level-1 { padding-left: 2.5em !important; }
        .task-level-2 { padding-left: 4.5em !important; }
        .task-level-3 { padding-left: 6.5em !important; }
        .task-level-4 { padding-left: 8.5em !important; }
        .task-bar {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .priority-1 { background: #f56565; }
        .priority-2 { background: #f6e05e; }
        .priority-3 { background: #68d391; }
        .priority-4 { background: #4299e1; }
        .priority-5 { background: #a0aec0; }
        .timeline-cell {
            position: relative;
            background: #fafafa;
        }
        .settings-fab {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 30;
        }
        .group-header {
            display: flex;
            align-items: center;
            gap: 0.5em;
        }
        .group-icon {
            width: 20px;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .group-row .group-icon {
            font-size: 14px;
        }
        .task-row:not(.group-row) .group-icon {
            font-size: 11px;
        }
        .is-collapsed > .task-cell .group-icon {
            transform: rotate(-90deg);
        }
        .is-hidden-by-parent {
            display: none;
        }
        .group-row .task-bar {
            opacity: 0.7 !important;
            height: 27px;
        }
        .task-row:not(.group-row) .task-bar {
            opacity: 0.5 !important;
            height: 18px;
        }
        .milestone {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3860;
            cursor: move;
            top: -12px;
            transform: translateX(-50%);
            z-index: 3;
            transition: border-bottom-color 0.2s ease;
        }
        .milestone.dragging {
            border-bottom-color: #ff1744;
            opacity: 0.8;
            z-index: 1000;
        }
        .milestone:hover {
            border-bottom-color: #ff1744;
        }
        .milestone-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #dbdbdb;
            font-size: 10px;
            white-space: nowrap;
            z-index: 4;
            display: none;
        }
        .milestone:hover .milestone-label {
            display: block;
        }
        .milestone-menu {
            position: fixed;
            background: white;
            border: 1px solid #dbdbdb;
            border-radius: 4px;
            padding: 0.75rem;
            box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1);
            z-index: 1000;
            min-width: 200px;
            display: none;
        }
        .milestone-menu.is-active {
            display: block;
        }
        .task-bar.is-invalid {
            background: repeating-linear-gradient(
                45deg,
                #ff3860,
                #ff3860 10px,
                #ffb3b3 10px,
                #ffb3b3 20px
            );
            opacity: 0.5 !important;
        }
        .task-bar.date-missing {
            background: repeating-linear-gradient(
                45deg,
                currentColor,
                currentColor 10px,
                transparent 10px,
                transparent 20px
            );
            opacity: 0.3 !important;
        }
        .task-cell .status-icon {
            margin-left: 8px;
            font-size: 12px;
        }
        .task-cell .invalid-dates {
            color: #ff3860;
        }
        .task-cell .missing-dates {
            color: #ffdd57;
        }
        .error-message {
            color: #ff3860;
            font-size: 12px;
            margin-top: 4px;
        }
    </style>
    </head>
    <body>
    <div class="file-input-wrapper">
        <div class="file has-name">
            <label class="file-label">
                <input class="file-input" type="file" id="fileInput" accept=".xlsx,.xls">
                <span class="file-cta">
                    <span class="file-icon">
                        <i class="fas fa-upload"></i>
                    </span>
                    <span class="file-label">
                        Choisir un fichier
                    </span>
                </span>
                <span class="file-name" id="fileName">
                    Aucun fichier sélectionné
                </span>
            </label>
        </div>
    </div>

    <div class="table-container">
        <table class="gantt-table" id="ganttTable"></table>
    </div>

    <button class="button is-info is-rounded settings-fab" onclick="toggleSettings()">
        <span class="icon">
            <i class="fas fa-cog"></i>
        </span>
    </button>

    <div class="modal" id="settingsMenu">
        <div class="modal-background" onclick="toggleSettings()"></div>
        <div class="modal-card">
            <header class="modal-card-head">
                <p class="modal-card-title">Paramètres</p>
                <button class="delete" aria-label="close" onclick="toggleSettings()"></button>
            </header>
            <section class="modal-card-body">
                <div class="field">
                    <label class="label">Colonne clé primaire</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="primaryKeySelect" onchange="updatePrimaryKey(this.value)"></select>
                        </div>
                    </div>
                </div>
                <button class="button is-primary" onclick="showImportSettings()">
                    Modifier les options d'import
                </button>
            </section>
        </div>
    </div>

    <div class="modal" id="importModal">
        <div class="modal-background" onclick="closeImportModal()"></div>
        <div class="modal-card">
            <header class="modal-card-head">
                <p class="modal-card-title">Import Excel</p>
                <button class="delete" aria-label="close" onclick="closeImportModal()"></button>
            </header>
            <section class="modal-card-body">
                <div class="field">
                    <label class="label">Sélectionnez l'onglet</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="sheetSelect"></select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Sujet</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="map_name"></select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Action</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="map_subName"></select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Priorité</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="map_priority"></select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Date début</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="map_startDate"></select>
                        </div>
                    </div>
                </div>
                <div class="field">
                    <label class="label">Date fin</label>
                    <div class="control">
                        <div class="select is-fullwidth">
                            <select id="map_endDate"></select>
                        </div>
                    </div>
                </div>
            </section>
            <footer class="modal-card-foot">
                <button class="button is-success" onclick="importData()">Importer</button>
                <button class="button" onclick="closeImportModal()">Annuler</button>
            </footer>
        </div>
    </div>

    <div class="milestone-menu" id="milestoneMenu">
        <div class="field">
            <input class="input is-small" type="text" id="milestoneName" placeholder="Nom du jalon">
        </div>
        <div class="field">
            <input class="input is-small" type="date" id="milestoneDate">
        </div>
        <div class="buttons are-small">
            <button class="button is-primary" onclick="saveMilestone()">Ajouter</button>
            <button class="button is-danger" onclick="deleteMilestone()" id="deleteMilestoneBtn" style="display: none;">Supprimer</button>
            <button class="button" onclick="closeMilestoneMenu()">Annuler</button>
        </div>
    </div>
    <script>
    const CONFIG_KEY = 'gantt_import_config';
    const MILESTONES_KEY = 'gantt_milestones';
    let tasks = [];
    let columns = [];
    let primaryKeyColumn = 0;
    let currentWorkbook = null;
    let currentCell = null;
    let currentMilestone = null;
    const months = 24;

    function findCellForDate(date, rowId) {
        const monthIndex = (date.getFullYear() - 2024) * 12 + date.getMonth();
        const cellId = `${rowId}_${monthIndex}`;
        return document.querySelector(`[data-cell-id="${cellId}"]`);
    }

    function saveConfiguration() {
        const config = {
            primaryKeyColumn,
            mapping: {
                name: document.getElementById('map_name').value,
                subName: document.getElementById('map_subName').value,
                priority: document.getElementById('map_priority').value,
                startDate: document.getElementById('map_startDate').value,
                endDate: document.getElementById('map_endDate').value
            },
            lastSheet: document.getElementById('sheetSelect').value
        };
        localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
    }

    function loadConfiguration() {
        const savedConfig = localStorage.getItem(CONFIG_KEY);
        if (savedConfig) {
            try {
                return JSON.parse(savedConfig);
            } catch (e) {
                console.error('Erreur lors du chargement de la configuration:', e);
                return null;
            }
        }
        return null;
    }

    function applyConfiguration(config) {
        if (!config) return;
        if (config.primaryKeyColumn !== undefined) {
            primaryKeyColumn = config.primaryKeyColumn;
            const primaryKeySelect = document.getElementById('primaryKeySelect');
            if (primaryKeySelect) {
                primaryKeySelect.value = config.primaryKeyColumn;
            }
        }
        if (config.mapping) {
            Object.entries(config.mapping).forEach(([field, value]) => {
                const select = document.getElementById(`map_${field}`);
                if (select && value !== undefined) {
                    select.value = value;
                }
            });
        }
        if (config.lastSheet) {
            const sheetSelect = document.getElementById('sheetSelect');
            if (sheetSelect) {
                sheetSelect.value = config.lastSheet;
            }
        }
    }

    function loadMilestones() {
        const saved = localStorage.getItem(MILESTONES_KEY);
        return saved ? JSON.parse(saved) : {};
    }

    function saveMilestones(milestones) {
        try {
            localStorage.setItem(MILESTONES_KEY, JSON.stringify(milestones));
        } catch (e) {
            console.error('Erreur lors de la sauvegarde des jalons:', e);
        }
    }

    function dateToPosition(date, cell) {
        const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
        const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
        const daysInMonth = monthEnd.getDate();
        
        const dayPosition = (date.getDate() - 1) / daysInMonth;
        return Math.min(Math.max(dayPosition * 100, 0), 100);
    }

    function positionToDate(position, cell) {
        const monthIndex = parseInt(cell.dataset.cellId.split('_')[1]);
        const monthStart = new Date(2024, monthIndex, 1);
        const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
        const daysInMonth = monthEnd.getDate();
        
        const dayIndex = Math.min(Math.max(Math.round((position / 100) * daysInMonth), 1), daysInMonth);
        return new Date(2024, monthIndex, dayIndex);
    }

    function parseDate(dateStr) {
        if (!dateStr) return null;
        
        if (dateStr instanceof Date) {
            return isNaN(dateStr.getTime()) ? null : dateStr;
        }
        
        let date = null;
        
        if (typeof dateStr === 'number') {
            date = new Date((dateStr - 25569) * 86400 * 1000);
            if (!isNaN(date.getTime())) return date;
        }
        
        if (typeof dateStr === 'string') {
            date = new Date(dateStr);
            if (!isNaN(date.getTime())) return date;
            
            const parts = dateStr.split(/[\/\-\.]/);
            if (parts.length === 3) {
                date = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
                if (!isNaN(date.getTime())) return date;
                
                date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
                if (!isNaN(date.getTime())) return date;
            }
        }
        
        return null;
    }

    function moveMilestoneToCell(milestone, oldCellId, newCell) {
        const milestones = loadMilestones();
        
        if (milestones[oldCellId]) {
            milestones[oldCellId] = milestones[oldCellId].filter(m => m.id !== milestone.id);
            if (milestones[oldCellId].length === 0) {
                delete milestones[oldCellId];
            }
        }
        
        const newCellId = newCell.dataset.cellId;
        if (!milestones[newCellId]) {
            milestones[newCellId] = [];
        }
        
        const position = dateToPosition(new Date(milestone.date), newCell);
        milestone.position = position;
        
        milestones[newCellId].push(milestone);
        saveMilestones(milestones);
    }
</script>
<script>
    function createMilestoneElement(milestone, cell) {
        const element = document.createElement('div');
        element.className = 'milestone';
        element.style.left = `${milestone.position}%`;
        
        const label = document.createElement('div');
        label.className = 'milestone-label';
        label.textContent = milestone.name;
        element.appendChild(label);

        element.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            showMilestoneMenu(e, milestone, cell);
        });
        
        element.draggable = true;
        let startX = 0;
        let startLeft = 0;

        element.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', '');
            element.classList.add('dragging');
            startX = e.clientX;
            startLeft = parseFloat(element.style.left);
        });

        element.addEventListener('drag', (e) => {
            if (e.clientX === 0) return;
            const cellRect = cell.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const newPosition = startLeft + (deltaX / cellRect.width) * 100;
            
            if (newPosition >= 0 && newPosition <= 100) {
                element.style.left = `${newPosition}%`;
            }
        });

        element.addEventListener('dragend', (e) => {
            const cellRect = cell.getBoundingClientRect();
            const position = ((e.clientX - cellRect.left) / cellRect.width) * 100;
            if (position >= 0 && position <= 100) {
                updateMilestonePosition(milestone, position, cell);
            }
            element.classList.remove('dragging');
        });

        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startX = e.touches[0].clientX;
            startLeft = parseFloat(element.style.left);
            element.classList.add('dragging');
        });

        element.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const cellRect = cell.getBoundingClientRect();
            const deltaX = e.touches[0].clientX - startX;
            const newPosition = startLeft + (deltaX / cellRect.width) * 100;
            
            if (newPosition >= 0 && newPosition <= 100) {
                element.style.left = `${newPosition}%`;
            }
        });

        element.addEventListener('touchend', (e) => {
            const position = parseFloat(element.style.left);
            if (position >= 0 && position <= 100) {
                updateMilestonePosition(milestone, position, cell);
            }
            element.classList.remove('dragging');
        });

        return element;
    }

    function showMilestoneMenu(e, existingMilestone = null, cell = null) {
        e.preventDefault();
        e.stopPropagation();

        const menu = document.getElementById('milestoneMenu');
        const nameInput = document.getElementById('milestoneName');
        const dateInput = document.getElementById('milestoneDate');
        const deleteBtn = document.getElementById('deleteMilestoneBtn');

        currentCell = cell;
        currentMilestone = existingMilestone;

        menu.style.left = `${e.pageX}px`;
        menu.style.top = `${e.pageY}px`;

        if (existingMilestone) {
            nameInput.value = existingMilestone.name;
            dateInput.value = existingMilestone.date;
            deleteBtn.style.display = 'block';
        } else {
            nameInput.value = '';
            dateInput.value = '';
            deleteBtn.style.display = 'none';
        }

        menu.classList.add('is-active');
    }

    function saveMilestone() {
        if (!currentCell) return;

        const name = document.getElementById('milestoneName').value;
        const date = document.getElementById('milestoneDate').value;
        if (!name || !date) return;

        const newDate = new Date(date);
        const rowId = currentCell.dataset.cellId.split('_')[0];
        const targetCell = findCellForDate(newDate, rowId);

        if (!targetCell) {
            console.error('Impossible de trouver la cellule cible pour la date:', date);
            return;
        }

        const milestones = loadMilestones();
        const position = dateToPosition(newDate, targetCell);
        
        const milestone = {
            id: currentMilestone?.id || Date.now(),
            name,
            date,
            position
        };

        if (currentMilestone) {
            const oldCellId = currentCell.dataset.cellId;
            const newCellId = targetCell.dataset.cellId;
            
            if (oldCellId !== newCellId) {
                moveMilestoneToCell(milestone, oldCellId, targetCell);
            } else {
                if (!milestones[newCellId]) {
                    milestones[newCellId] = [];
                }
                const index = milestones[newCellId].findIndex(m => m.id === currentMilestone.id);
                if (index !== -1) {
                    milestones[newCellId][index] = milestone;
                } else {
                    milestones[newCellId].push(milestone);
                }
                saveMilestones(milestones);
            }
        } else {
            const cellId = targetCell.dataset.cellId;
            if (!milestones[cellId]) {
                milestones[cellId] = [];
            }
            milestones[cellId].push(milestone);
            saveMilestones(milestones);
        }

        renderMilestones();
        closeMilestoneMenu();
    }

    function updateMilestonePosition(milestone, position, cell) {
        const date = positionToDate(position, cell);
        const rowId = cell.dataset.cellId.split('_')[0];
        const targetCell = findCellForDate(date, rowId);

        if (!targetCell) {
            console.error('Impossible de trouver la cellule cible pour la position:', position);
            return;
        }

        const milestones = loadMilestones();
        const oldCellId = cell.dataset.cellId;
        const newCellId = targetCell.dataset.cellId;

        milestone.date = date.toISOString().split('T')[0];
        milestone.position = position;

        if (oldCellId !== newCellId) {
            moveMilestoneToCell(milestone, oldCellId, targetCell);
        } else {
            if (!milestones[newCellId]) {
                milestones[newCellId] = [];
            }
            const index = milestones[newCellId].findIndex(m => m.id === milestone.id);
            if (index !== -1) {
                milestones[newCellId][index] = milestone;
            } else {
                milestones[newCellId].push(milestone);
            }
            saveMilestones(milestones);
        }

        renderMilestones();
    }

    function deleteMilestone() {
        if (!currentCell || !currentMilestone) return;

        const milestones = loadMilestones();
        const cellId = currentCell.dataset.cellId;
        
        if (milestones[cellId]) {
            milestones[cellId] = milestones[cellId].filter(m => m.id !== currentMilestone.id);
            if (milestones[cellId].length === 0) {
                delete milestones[cellId];
            }
            saveMilestones(milestones);
            renderMilestones();
        }
        
        closeMilestoneMenu();
    }

    function closeMilestoneMenu() {
        const menu = document.getElementById('milestoneMenu');
        menu.classList.remove('is-active');
        currentCell = null;
        currentMilestone = null;
    }

    function renderMilestones() {
        document.querySelectorAll('.milestone').forEach(m => m.remove());
        
        const milestones = loadMilestones();
        Object.entries(milestones).forEach(([cellId, cellMilestones]) => {
            const cell = document.querySelector(`[data-cell-id="${cellId}"]`);
            if (cell) {
                cellMilestones.forEach(milestone => {
                    if (typeof milestone.position !== 'number') {
                        milestone.position = dateToPosition(new Date(milestone.date), cell);
                    }
                    cell.appendChild(createMilestoneElement(milestone, cell));
                });
            }
        });
    }
</script>
<script>
    function toggleSettings() {
        document.getElementById('settingsMenu').classList.toggle('is-active');
    }

    function closeImportModal() {
        document.getElementById('importModal').classList.remove('is-active');
    }

    function updatePrimaryKey(columnIndex) {
        primaryKeyColumn = parseInt(columnIndex);
        createTable();
    }

    function toggleGroup(groupId) {
        const row = document.querySelector(`[data-group-id="${groupId}"]`);
        const wasCollapsed = row.classList.toggle('is-collapsed');
        const level = parseInt(row.dataset.level || '0');
        
        let next = row.nextElementSibling;
        while (next) {
            const nextLevel = parseInt(next.dataset.level || '0');
            if (nextLevel <= level) break;
            
            if (wasCollapsed) {
                next.classList.add('is-hidden-by-parent');
                if (next.classList.contains('group-row') && !next.classList.contains('is-collapsed')) {
                    next.dataset.wasExpanded = 'true';
                }
                next.classList.add('is-collapsed');
            } else {
                next.classList.remove('is-hidden-by-parent');
                if (next.classList.contains('group-row') && next.dataset.wasExpanded === 'true') {
                    next.classList.remove('is-collapsed');
                    next.removeAttribute('data-was-expanded');
                }
            }
            next = next.nextElementSibling;
        }
    }

    function validateTask(row, mapping) {
        const errors = [];
        const warnings = [];
        
        if (!row[columns[mapping.name]]) {
            errors.push("Nom manquant");
        }

        const startDate = parseDate(row[columns[mapping.startDate]]);
        const endDate = parseDate(row[columns[mapping.endDate]]);

        if (!startDate && !endDate) {
            warnings.push("Dates manquantes");
        } else {
            if (!startDate) warnings.push("Date de début manquante");
            if (!endDate) warnings.push("Date de fin manquante");
            
            if (startDate && endDate && startDate > endDate) {
                errors.push("La date de fin est antérieure à la date de début");
            }
        }

        return { errors, warnings };
    }

    function createTimelineBar(timelineCell, item, startMonth, endMonth, level, i) {
        const hasValidDates = item.start && 
                            item.end && 
                            item.start instanceof Date && 
                            item.end instanceof Date && 
                            !isNaN(item.start.getTime()) && 
                            !isNaN(item.end.getTime());

        if (!hasValidDates) {
            const bar = document.createElement('div');
            bar.className = `task-bar priority-${item.priority} date-missing`;
            bar.style.width = '100%';
            bar.style.opacity = level === 0 ? '0.3' : '0.8';
            timelineCell.appendChild(bar);
            return;
        }

        if (item.hasError) {
            const bar = document.createElement('div');
            bar.className = `task-bar is-invalid`;
            bar.style.width = '100%';
            timelineCell.appendChild(bar);
            return;
        }

        if (i >= startMonth && i <= endMonth) {
            const bar = document.createElement('div');
            bar.className = `task-bar priority-${item.priority}`;
            bar.style.width = '100%';
            bar.style.opacity = level === 0 ? '0.3' : '0.8';
            timelineCell.appendChild(bar);
            timelineCell.addEventListener('contextmenu', (e) => showMilestoneMenu(e, null, timelineCell));
        }
    }

    function createTable() {
        const table = document.getElementById('ganttTable');
        table.innerHTML = '';
        
        const thead = document.createElement('tr');
        thead.innerHTML = `
            <th class="task-cell has-background-white">Action</th>
            ${Array.from({length: months}, (_, i) => {
                const date = new Date(2024, i, 1);
                return `<th class="has-text-centered">${date.toLocaleDateString('fr', {month: 'short', year: '2-digit'})}</th>`;
            }).join('')}
        `;
        table.appendChild(thead);

        let rowId = 0;
        function createRows(items, level = 0) {
            items.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'task-row';
                if (item.hasError) {
                    row.classList.add('has-error');
                }
                row.dataset.level = level;
                const currentRowId = rowId++;
                row.dataset.groupId = currentRowId;

                const hasSubItems = item.tasks && item.tasks.length > 0;
                if (hasSubItems) {
                    row.classList.add('group-row');
                }

                const cell = document.createElement('td');
                cell.className = `task-cell task-level-${level}`;

                let cellContent = `
                    ${hasSubItems ? 
                        `<span class="group-icon" onclick="event.stopPropagation(); toggleGroup(${currentRowId})">
                            <i class="fas fa-chevron-down"></i>
                        </span>` : 
                        `<span class="group-icon"></span>`
                    }
                    <span class="group-name">${item.name}</span>
                `;

                if (item.hasError || item.hasWarning) {
                    cellContent += `
                        <span class="error-tooltip">
                            ${item.hasError ? 
                                `<i class="fas fa-exclamation-circle status-icon invalid-dates"></i>` : 
                                `<i class="fas fa-exclamation-triangle status-icon missing-dates"></i>`
                            }
                            <span class="error-message">
                                ${item.hasError ? 'Erreurs :' : 'Avertissements :'}
                                <ul class="error-list">
                                    ${[...(item.errors || []), ...(item.warnings || [])].map(msg => `<li>${msg}</li>`).join('')}
                                </ul>
                            </span>
                        </span>
                    `;
                }

                cell.innerHTML = cellContent;
                row.appendChild(cell);

                let startMonth = 0;
                let endMonth = months - 1;

                if (item.start && item.start instanceof Date && !isNaN(item.start.getTime())) {
                    startMonth = (item.start.getFullYear() - 2024) * 12 + item.start.getMonth();
                }
                
                if (item.end && item.end instanceof Date && !isNaN(item.end.getTime())) {
                    endMonth = (item.end.getFullYear() - 2024) * 12 + item.end.getMonth();
                }

                startMonth = Math.max(0, Math.min(startMonth, months - 1));
                endMonth = Math.max(0, Math.min(endMonth, months - 1));
                
                for (let i = 0; i < months; i++) {
                    const timelineCell = document.createElement('td');
                    timelineCell.className = 'timeline-cell';
                    timelineCell.dataset.cellId = `${currentRowId}_${i}`;
                    
                    createTimelineBar(timelineCell, item, startMonth, endMonth, level, i);
                    
                    row.appendChild(timelineCell);
                }
                
                table.appendChild(row);

                if (item.tasks) {
                    const subItems = item.tasks
                        .filter(task => task && task.name)
                        .map(task => ({
                            ...task,
                            tasks: []
                        }));
                    
                    if (subItems.length > 0) {
                        createRows(subItems, level + 1);
                    }
                }
            });
        }

        if (tasks.length > 0) {
            createRows(tasks);
        }
        
        renderMilestones();
    }

    function updateColumns() {
        if (!currentWorkbook) return;
        
        const sheetSelect = document.getElementById('sheetSelect');
        const sheet = currentWorkbook.Sheets[sheetSelect.value];
        
        const ref = XLSX.utils.decode_range(sheet['!ref']);
        columns = [];
        for(let C = ref.s.c; C <= ref.e.c; C++) {
            const header = sheet[XLSX.utils.encode_cell({r:0, c:C})];
            columns.push(header ? header.v : `Colonne ${C + 1}`);
        }
        
        const savedConfig = loadConfiguration();
        
        const selects = ['name', 'subName', 'priority', 'startDate', 'endDate'];
        selects.forEach(field => {
            const select = document.getElementById(`map_${field}`);
            select.innerHTML = `<option value="">Sélectionner...</option>` +
                columns.map((h, i) => `<option value="${i}">${h}</option>`).join('');
                
            if (savedConfig?.mapping?.[field] !== undefined) {
                if (select.querySelector(`option[value="${savedConfig.mapping[field]}"]`)) {
                    select.value = savedConfig.mapping[field];
                }
            }
        });
        
        const primaryKeySelect = document.getElementById('primaryKeySelect');
        primaryKeySelect.innerHTML = columns.map((h, i) => `<option value="${i}">${h}</option>`).join('');
        if (savedConfig?.primaryKeyColumn !== undefined) {
            if (primaryKeySelect.querySelector(`option[value="${savedConfig.primaryKeyColumn}"]`)) {
                primaryKeySelect.value = savedConfig.primaryKeyColumn;
                primaryKeyColumn = savedConfig.primaryKeyColumn;
            }
        }
    }

    function showImportSettings() {
        if (currentWorkbook) {
            document.getElementById('importModal').classList.add('is-active');
            document.getElementById('settingsMenu').classList.remove('is-active');
        }
    }

    function importData() {
        if (!currentWorkbook) return;
        
        saveConfiguration();
        
        const mapping = {};
        ['name', 'subName', 'priority', 'startDate', 'endDate'].forEach(field => {
            mapping[field] = document.getElementById(`map_${field}`).value;
        });
        
        const sheet = currentWorkbook.Sheets[document.getElementById('sheetSelect').value];
        const rawData = XLSX.utils.sheet_to_json(sheet, { header: columns });
        
        tasks = rawData.map(row => {
            const { errors, warnings } = validateTask(row, mapping);
            const startDate = parseDate(row[columns[mapping.startDate]]);
            const endDate = parseDate(row[columns[mapping.endDate]]);
            
            return {
                name: row[columns[mapping.name]] || '(Sans nom)',
                subName: mapping.subName ? row[columns[mapping.subName]] : null,
                priority: parseInt(row[columns[mapping.priority]]) || 3,
                start: startDate || new Date(2024, 0, 1),
                end: endDate || new Date(2024, 11, 31),
                rawData: row,
                errors,
                warnings,
                hasError: errors.length > 0,
                hasWarning: warnings.length > 0
            };
        }).filter(task => task.name);
        
        createTable();
        document.getElementById('importModal').classList.remove('is-active');
    }

    document.getElementById('fileInput').onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('fileName').textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                currentWorkbook = XLSX.read(data, {type: 'array'});
                
                const sheetSelect = document.getElementById('sheetSelect');
                sheetSelect.innerHTML = currentWorkbook.SheetNames.map(name =>
                    `<option value="${name}">${name}</option>`
                ).join('');

                const savedConfig = loadConfiguration();
                if (savedConfig?.lastSheet && sheetSelect.querySelector(`option[value="${savedConfig.lastSheet}"]`)) {
                    sheetSelect.value = savedConfig.lastSheet;
                }

                sheetSelect.onchange = updateColumns;
                updateColumns();
                document.getElementById('importModal').classList.add('is-active');
            };
            reader.readAsArrayBuffer(file);
        }
    };

    document.addEventListener('click', (e) => {
        const menu = document.getElementById('milestoneMenu');
        if (!menu.contains(e.target) && !e.target.classList.contains('milestone')) {
            closeMilestoneMenu();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        const savedConfig = loadConfiguration();
        if (savedConfig) {
            primaryKeyColumn = savedConfig.primaryKeyColumn;
        }
        createTable();
    });
// Mise à jour de la fonction toggleGroup
function toggleGroup(groupId) {
    const row = document.querySelector(`[data-group-id="${groupId}"]`);
    if (!row) return;
    
    const wasCollapsed = row.classList.toggle('is-collapsed');
    const level = parseInt(row.dataset.level || '0');
    
    let next = row.nextElementSibling;
    while (next) {
        const nextLevel = parseInt(next.dataset.level || '0');
        if (nextLevel <= level) break;
        
        if (wasCollapsed) {
            next.classList.add('is-hidden-by-parent');
            // Sauvegarder l'état déplié si c'était un groupe déplié
            if (next.classList.contains('group-row') && !next.classList.contains('is-collapsed')) {
                next.dataset.wasExpanded = 'true';
            }
        } else {
            next.classList.remove('is-hidden-by-parent');
            // Restaurer l'état déplié précédent
            if (next.classList.contains('group-row') && next.dataset.wasExpanded === 'true') {
                next.classList.remove('is-collapsed');
                next.removeAttribute('data-was-expanded');
            }
        }
        next = next.nextElementSibling;
    }
}

function createRows(items, level = 0) {
    items.forEach(item => {
        // Création de la ligne
        const row = document.createElement('tr');
        row.className = 'task-row';
        if (item.hasError) {
            row.classList.add('has-error');
        }
        row.dataset.level = level;
        const currentRowId = rowId++;
        row.dataset.groupId = currentRowId;

        // Vérification des sous-éléments
        const hasSubItems = item.tasks && item.tasks.length > 0;
        if (hasSubItems) {
            row.classList.add('group-row');
        }

        // Création de la cellule de titre
        const cell = document.createElement('td');
        cell.className = `task-cell task-level-${level}`;

        // Construction du contenu de la cellule
        let cellContent = '';
        
        // Ajout de l'icône de pliage/dépliage pour les groupes
        if (hasSubItems) {
            cellContent = `
                <span class="group-icon" onclick="toggleGroup(${currentRowId}); event.stopPropagation();">
                    <i class="fas fa-chevron-down"></i>
                </span>
            `;
        } else {
            cellContent = `
                <span class="group-icon">
                    <i class="fas fa-minus"></i>
                </span>
            `;
        }

        // Ajout du nom
        cellContent += `<span class="group-name">${item.name}</span>`;

        // Ajout des indicateurs d'erreur/avertissement si nécessaire
        if (item.hasError || item.hasWarning) {
            cellContent += `
                <span class="error-tooltip">
                    ${item.hasError ? 
                        `<i class="fas fa-exclamation-circle status-icon invalid-dates"></i>` : 
                        `<i class="fas fa-exclamation-triangle status-icon missing-dates"></i>`
                    }
                    <span class="error-message">
                        ${item.hasError ? 'Erreurs :' : 'Avertissements :'}
                        <ul class="error-list">
                            ${[...(item.errors || []), ...(item.warnings || [])].map(msg => `<li>${msg}</li>`).join('')}
                        </ul>
                    </span>
                </span>
            `;
        }

        cell.innerHTML = cellContent;
        row.appendChild(cell);

        // Gestion des dates de début et fin
        let startMonth = 0;
        let endMonth = months - 1;

        if (item.start && item.start instanceof Date && !isNaN(item.start.getTime())) {
            startMonth = (item.start.getFullYear() - 2024) * 12 + item.start.getMonth();
        }
        
        if (item.end && item.end instanceof Date && !isNaN(item.end.getTime())) {
            endMonth = (item.end.getFullYear() - 2024) * 12 + item.end.getMonth();
        }

        // S'assurer que les mois sont dans les limites valides
        startMonth = Math.max(0, Math.min(startMonth, months - 1));
        endMonth = Math.max(0, Math.min(endMonth, months - 1));
        
        // Création des cellules de timeline
        for (let i = 0; i < months; i++) {
            const timelineCell = document.createElement('td');
            timelineCell.className = 'timeline-cell';
            timelineCell.dataset.cellId = `${currentRowId}_${i}`;
            
            // Création de la barre de timeline
            if (i >= startMonth && i <= endMonth) {
                const bar = document.createElement('div');
                bar.className = `task-bar priority-${item.priority}`;
                
                // Gestion des états spéciaux (erreurs, dates manquantes)
                if (!item.start || !item.end || isNaN(item.start.getTime()) || isNaN(item.end.getTime())) {
                    bar.classList.add('date-missing');
                } else if (item.hasError) {
                    bar.classList.add('is-invalid');
                }
                
                bar.style.width = '100%';
                bar.style.opacity = level === 0 ? '0.3' : '0.8';
                timelineCell.appendChild(bar);
                
                // Ajout du gestionnaire de clic droit pour les jalons
                timelineCell.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMilestoneMenu(e, null, timelineCell);
                });
            }
            
            row.appendChild(timelineCell);
        }
        
        // Ajout de la ligne au tableau
        table.appendChild(row);

        // Traitement récursif des sous-éléments
        if (item.tasks) {
            const subItems = item.tasks
                .filter(task => task && task.name)  // Filtrer les tâches valides
                .map(task => ({
                    ...task,
                    tasks: []
                }));
            
            if (subItems.length > 0) {
                createRows(subItems, level + 1);
            }
        }
    });
}

// Ajout/Mise à jour des styles CSS nécessaires
const additionalStyles = `
.is-collapsed > .task-cell .group-icon i {
    transform: rotate(-90deg);
}

.is-hidden-by-parent {
    display: none !important;
}

.group-icon {
    width: 20px;
    min-width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 8px;
    cursor: pointer;
}

.group-icon i {
    transition: transform 0.2s ease;
}

.group-row .task-cell {
    cursor: pointer;
}

.task-cell {
    user-select: none;
}
`;
    
</script>
</body>
</html>
